---
title: undefined
slug: Web/JavaScript/Reference/Global_Objects/undefined
translation_of: Web/JavaScript/Reference/Global_Objects/undefined
---
<div>
<div>
<div>{{jsSidebar("Objects")}}</div>

<div>全局属性<code><strong>undefined</strong></code>表示原始值<code>{{Glossary("Undefined", "undefined")}}。</code>它是一个JavaScript的 {{Glossary("Primitive", "原始数据类型")}} 。</div>



<div>{{js_property_attributes(0,0,0)}}</div>



<div>
<div>{{EmbedInteractiveExample("pages/js/globalprops-undefined.html")}}</div>
</div>
</div>
</div>

<h2 id="Syntax">语法</h2>

<pre class="syntaxbox"><code>undefined </code></pre>

<h2 id="Description">描述</h2>

<p><code>undefined</code>是<em>全局对象</em>的一个属性。也就是说，它是全局作用域的一个变量。<code>undefined</code>的最初值就是原始数据类型<code>{{Glossary("Undefined", "undefined")}}</code>。</p>

<p>在现代浏览器（JavaScript 1.8.5/Firefox 4+），自ECMAscript5标准以来undefined是一个不能被配置（non-configurable），不能被重写（non-writable）的属性。即便事实并非如此，也要避免去重写它。</p>

<p>一个没有被赋值的变量的类型是undefined。如果方法或者是语句中<strong>操作的变量没有被赋值，则会返回undefined</strong>（对于这句话持疑惑态度，请查看英文原文来理解）。</p>

<pre class="brush: js">function test(a){
    console.log(typeof a);    // undefined
    return a;
}

test();                       // 返回"undefined"</pre>

<p>一个函数如果没有使用return语句指定{{jsxref("Statements/return", "返回")}}值，就会返回一个undefined值。</p>

<div class="warning">
<p><strong>警告：</strong>但是它有可能在非全局作用域中被当作{{Glossary("Identifier", "标识符")}}（变量名）来使用(因为undefined不是一个{{jsxref("Reserved_Words", "保留字")}}))，这样做是一个非常坏的主意，因为这样会使你的代码难以去维护和排错。</p>

<pre class="brush: js">// 不要这样做！

// 打印 'foo string' PS：说明undefined的值和类型都已经改变
(function() {
var undefined = 'foo';
console.log(undefined, typeof undefined)
})()

// 打印 'foo string' PS：说明undefined的值和类型都已经改变
(function(undefined) {
console.log(undefined, typeof undefined)
})('foo')

</pre>
</div>

<h2 id="示例">示例</h2>

<h3 id="严格相等和undefined">严格相等和undefined</h3>

<p>你可以使用undefined和严格相等或不相等操作符来决定一个变量是否拥有值。在下面的代码中，变量x是未定义的，if 语句的求值结果将是true</p>

<pre class="brush: js">var x;

if (x === undefined) {
// 执行这些语句
} else {
// 这些语句不会被执行
}</pre>

<div class="note">
<p><strong>备注：</strong>这里是必须使用严格相等操作符（===）而不是标准相等操作符（==），因为 x == undefined 会检查x是不是null，但是严格相等不会检查（有点饶人，其实 === 会严格判断双方的类型、值等是否相等）。null不等同于undefined。移步{{jsxref("Operators/Comparison_Operators", "比较操作符")}}查看详情。</p>
</div>

<h3 id="Typeof_操作符和undefined">Typeof 操作符和undefined</h3>

<p>或者，可以使用{{jsxref("Operators/typeof", "typeof")}}：</p>

<pre class="brush: js">var x;
if(typeof x === 'undefined') {
    // 执行这些语句
}</pre>

<p>使用 {{jsxref("Operators/typeof", "typeof")}}的原因是它不会在一个变量没有被声明的时候抛出一个错误。</p>

<pre class="brush: js">// 这里没有声明y
if(typeof y === 'undefined') {       // 没有错误，执行结果为true
   console.log("y is " + typeof y )  // y is undefined
}

if(y === undefined) {                // ReferenceError: y is not defined

}</pre>

<p>但是，技术方面看来这样的使用方法应该被避免。JavaScript是一个静态作用域语言，所以，一个变量是否被声明可以通过看它是否在一个封闭的上下文中被声明。唯一的例外是全局作用域，但是全局作用域是被绑定在全局对象上的，所以要检查一个变量是否在全局上下文中存在可以通过检查全局对象上是否存在这个属性（比如使用{{jsxref("Operators/in", "in")}}操作符）。</p>

<pre class="brush: js">if ('x' in window) {
  // 只有x被全局性的定义 才会这行这些语句
}</pre>

<h3 id="Void操作符和undefined">Void操作符和undefined</h3>

<p>{{jsxref("Operators/void", "void")}} 操作符是第三种可以替代的方法。</p>

<pre class="brush: js">var x;
if(x === void 0) {
    // 执行这些语句
}

// 没有声明y
if(y === void 0) {
    // 抛出一个RenferenceError错误(与`typeof`相比)
}
</pre>

<h2 id="规范">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-undefined', 'undefined')}}</td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>

<p>{{Compat("javascript.builtins.undefined")}}</p>
